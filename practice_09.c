/* 2019年10月22日 16:38:07 */
#include<stdio.h>
/*
(2009年第42题)已知一个带有表头结点的单链表，结点结构为：data,link
假设该链表只给出了头指针list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。
若查找成功，算法输出该结点的data域的值，并返回1；否则，只返回0。要求：
1）描述算法的基本设计思想。
2）描述算法的详细实现步骤。
3）根据设计思想和实现步骤，采用程序设计语言描述算法（使用C、C++或Java语言实现），关键之处请给出简要注释。
*/

/*
第一问:
定义指针p和q,初始化均为单链表的首元结点。首先将p的指针沿着链表指向k的位置，而q的指针保持不变
当p移动到k+1时，p和q之间的距离为k，然后p和q同时下移，当p为NULL是，q所指向的指针即为该链的倒数第k个节点

算法描述:
1. 计数器i=0,用指针p和q指向首元结点
2. 从首元结点开始依次沿着链域link依次遍历链表，若p为NULL,则转为步骤5
3. 若i小于k，则i+1，否则q指向下一个节点
4. p指向下一个结点，返回步骤5
5. 若i等于k，则查找成功,输出该节点的data域，返回1，否则返回0
*/

typedef struct LNode
{
	int data;
	struct LNode * next;
}LNode, * LinkList;

// 查找链表List中的倒数第k的位置
int Search_k(LinkList list, int k)
{
	i = 0; // 计时器初值
	p = q = Llsi->next;  // p和q均指向首元结点

	while (p != NULL) // 顺着指针域往后扫描，直到p为空
	{
		if (i < k) { // 计数器+1     0~k-1  移动k次
			i++;  
		}
		else  // 此时p的位置到了k+1
			q = q->next;  // q移到下一个结点
		}
		p = p->next;  // p移到下一个指针
	}
	if (i == k)
	{
		count<<q->data;
		return 1;
	}
	else
	{
		return 0;
	}
}
